/*
* Copyright (C) 2025 Filip Chovanec
*
* This program is free software: you can redistribute it and/or modify
* it under the terms of the GNU General Public License as published by
* the Free Software Foundation, either version 3 of the License, or
* (at your option) any later version.
*
* This program is distributed in the hope that it will be useful,
* but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
* GNU General Public License for more details.
*
* You should have received a copy of the GNU General Public License
* along with this program.  If not, see <https://www.gnu.org/licenses/>.
*/

use clap::Parser;
use std::env;
use std::fs;
use std::io;
use std::io::Write;
use std::path::{Path, PathBuf};
use std::process::Command;

use serde::Deserialize;

pub mod backends;
pub mod frontend;
pub mod state;
#[cfg(test)]
pub mod test;

fn repl(targetspec: TargetSpec) {
    // temporary disable because of how the repl pastes code into main directly
    if targetspec.backend == "NASM64" {
        panic!("NASM64 unsupported for repl currently");
    }

    loop {
        print!("Dryft repl> ");
        io::stdout().flush().unwrap(); // flush so it appears immediately
        let mut input = String::new();
        io::stdin()
            .read_line(&mut input)
            .expect("Failed to read line");
        if input.trim().is_empty() {
            continue;
        }

        match input.trim() {
            ".help" | "help" => {
                println!(".help/help  => display this screen");
                println!(".exit/.quit => leave the REPL, terminating this process");
                println!(".view       => inspect the contents of generated IR from last execution")
            }
            ".view" => {
                let ir = &String::from_utf8(fs::read(&targetspec.intermediate).unwrap()).unwrap();
                println!("{}", ir);
            }
            ".exit" | ".quit" => break,
            _ => {
                let src = format!("include std/io act: main {} ;", input);
                let backend = crate::backends::select(&targetspec.backend);
                fs::write(
                    &targetspec.intermediate,
                    frontend::compile_full(backend, &src),
                )
                .unwrap();
                stdlib(targetspec.stdlib.as_ref().unwrap_or(&"".to_string()));
                assemble(targetspec.assemble.as_ref().unwrap_or(&"".to_string()));
                link(targetspec.link.as_ref().unwrap_or(&"".to_string()));
                interpret(
                    targetspec
                        .interpret
                        .clone()
                        .unwrap_or("./a.out".to_string())
                        .as_ref(),
                );
            }
        }
    }
}

fn build_file(inp: &Path, out: &Path, backend_name: &str) {
    let src = &String::from_utf8(fs::read(inp).unwrap_or("".into())).unwrap();
    if src.is_empty() {
        println!("Nothing to compile :/");
    } else {
        let backend = crate::backends::select(backend_name);
        fs::write(out, frontend::compile_full(backend, src)).unwrap();
    }
}

// output the text or nothing if its n empty string
fn simple_print(x: &str) {
    print!("{}", x);
    io::stdout().flush().unwrap();
}

// compile the standard library
fn stdlib(cmd: &str) {
    let (_, stderr) = bash(cmd);
    simple_print(&stderr);
}

// pass IR generated by dryftc into an external compiler, like gcc or llvm
fn assemble(cmd: &str) {
    let (_, stderr) = bash(cmd);
    simple_print(&stderr);
}

// link objects into final executable
fn link(cmd: &str) {
    let (_, stderr) = bash(cmd);
    simple_print(&stderr);
}

// execute step after externalize(), necessary for VM-based backends
// TODO: currently waits for finish to disply stdout, which is not good for interactive apps. Start a proper process in future.
fn interpret(cmd: &str) {
    let (stdout, _) = bash(cmd);
    println!("{}", stdout);
}

// returns stdout and stderr post cmd execution
fn bash(cmd: &str) -> (String, String) {
    let output = Command::new("bash")
        .arg("-c")
        .arg(cmd)
        .output()
        .expect("Failed to execute bash");
    (
        String::from_utf8_lossy(&output.stdout).to_string(),
        String::from_utf8_lossy(&output.stderr).to_string(),
    )
}

#[derive(Deserialize)]
struct TargetDesc {
    // only provides linux support for now, windows/mac support in the future
    unix: Option<TargetSpec>,
    windows: Option<TargetSpec>,
}

// platform independent
#[derive(Deserialize)]
struct TargetSpec {
    //dependencies: Vec<String>,
    backend: String,
    intermediate: PathBuf,    // file to write dryftc output to
    assemble: Option<String>, // command describing how to use an external compiler to finalize compilation.
    link: Option<String>,
    interpret: Option<String>, // command to run the final product. If none, use default system execute function (TODO)
    stdlib: Option<String>,
}

#[derive(Parser, Debug)]
#[command(version, about, long_about = None)]
pub struct Cli {
    pub inputfile: Option<PathBuf>,

    #[arg(short = 't', long = "target")]
    #[arg(default_value = "gcc")]
    /// One of the targets defined in src/targets/
    pub target: String,

    /// only outputs the final dryftc assembly, no external tooling will be called
    #[arg(long = "assembly-only")]
    pub assembly_only: bool,

    /// only outputs an object file, without additional library linking
    #[arg(long = "object-only")]
    pub object_only: bool,

    /// output file where the dryftc assembly will be stored
    #[arg(short = 'a', long = "assembly-out")]
    pub assembly_out: Option<PathBuf>,

    /// provide a path to custom target.toml descriptor
    #[arg(long = "custom-target")]
    pub custom_target: Option<String>, // should be pathbuf but oh well

    /// Run the final executable using the pre-defined interpreter
    #[arg(short = 'r', long = "run")]
    pub is_run: bool,
}

fn main() {
    let cli = Cli::parse();

    let target_name = cli.target;
    let target_raw = String::from_utf8(
        fs::read(
            cli.custom_target
                .unwrap_or(format!("src/targets/{target_name}.toml")),
        )
        .expect("Unknown target"),
    )
    .expect("Bad utf8 in target description");
    let target_toml: TargetDesc = toml::from_str(&target_raw).expect("Invalid target description");

    // TODO: add external dependency checks

    let mut targetspec = match env::consts::FAMILY {
        "unix" => target_toml
            .unix
            .expect("Your platform (UNIX) does not yet support this target"),
        "windows" => target_toml
            .windows
            .expect("Your platform (WINDOWS) does not yet support this target"),
        other => panic!("Unknown host OS family {other}"),
    };

    if let Some(a) = cli.assembly_out {
        targetspec.intermediate = a;
    }

    if let Some(f) = cli.inputfile {
        build_file(&f, &targetspec.intermediate, &targetspec.backend);
        stdlib(&targetspec.stdlib.unwrap_or("".to_string()));
        if !cli.assembly_only {
            assemble(&targetspec.assemble.unwrap_or("".to_string()));
            if !cli.object_only {
                link(&targetspec.link.unwrap_or("".to_string()));
            }
        }
        if cli.is_run {
            interpret(
                targetspec
                    .interpret
                    .unwrap_or("./a.out".to_string())
                    .as_ref(),
            );
        }
    } else {
        repl(targetspec);
    }
}
