use std::process::Command;
use std::env;
use std::io;
use std::io::Write;
use std::fs;

use serde::Deserialize;
use toml;

pub mod backends;
pub mod frontend;

use backends::c99::C99Backend;
use backends::Backend;

type DefaultBackend = C99Backend;

fn repl(targetspec: TargetSpec) {
    loop {
        print!("Dryft repl> ");
        io::stdout().flush().unwrap();   // flush so it appears immediately
        let mut input = String::new();
        io::stdin()
            .read_line(&mut input)
            .expect("Failed to read line");
        if input.trim().is_empty() {
            continue;
        }
        match input.trim() {
            /*"#open" => {
                let mut fname = String::new();  
                io::stdin()
                    .read_line(&mut fname)
                    .expect("Failed to read line");
                rbr(fname.trim());
            }*/
            ".help" | "help" => {
                println!(".help/help  => display this screen");
                println!(".exit/.quit => leave the REPL, terminating this process");
            }
            ".exit" | ".quit" => {
                break
            }
            _ => {
                let src = format!("fun: main {} ;", input);
                let mut backend = DefaultBackend {};
                fs::write(&targetspec.intermediate, frontend::compile_full(backend, &src)).unwrap();
                if let Err(e) = externalize(&targetspec.externalize) {
                    println!("{}", e);
                } else {
                    interpret(targetspec.interpret.clone().unwrap().as_ref());
                }
            }
        }
    }
}

fn build_file(inp: &str, out: &str) {
    let src = &String::from_utf8(fs::read(inp).unwrap_or("".into())).unwrap();
    if src.is_empty() {
        println!("Nothing to compile :/");
    } else {
        let mut backend = DefaultBackend {};
        fs::write(out, frontend::compile_full(backend, src)).unwrap();   
    }
}

// pass IR generated by dryftc into an external compiler, like gcc or llvm
fn externalize(cmd: &str) -> Result<(), String> {
    let (_, stderr) = bash(cmd);
    if !stderr.is_empty() {
        return Err(stderr)
    }
    return Ok(())
}

// execute step after externalize(), necessary for VM-based backends
// TODO: currently waits for finish to disply stdout, which is not good for interactive apps. Start a proper process in future.
fn interpret(cmd: &str) {
    let (stdout, _) = bash("./a.out");
    println!("{}", stdout);  
}

// returns stdout and stderr post cmd execution
fn bash(cmd: &str) -> (String, String) {
    let output = Command::new("bash")
        .arg("-c")
        .arg(cmd)
        .output()
        .expect("Failed to execute bash");
    (String::from_utf8_lossy(&output.stdout).to_string(), String::from_utf8_lossy(&output.stderr).to_string())
}

#[derive(Deserialize)]
struct TargetDesc { 
    // only provides linux support for now, windows/mac support in the future
    linux: TargetSpec
}

// platform independent
#[derive(Deserialize)]
struct TargetSpec {
    dependencies: Vec<String>, // binaries used by the below
    intermediate: String, // file to write dryftc output to
    externalize: String, // command describing how to use an external compiler to finalize compilation. 
    interpret: Option<String>, // command to run the final product
}


fn main() {
    let args: Vec<String> = env::args().collect();
    let target_name = "c99"; // change this based on cli selection
    let target_raw = String::from_utf8(fs::read(&format!("src/targets/{target_name}.toml")).expect("Unknown target")).expect("Bad utf8 in target description");
    let target_toml: TargetDesc = toml::from_str(&target_raw).expect("Invalid target description");
    // TODO: add external dependency checks
    let targetspec = target_toml.linux; // change this based on current platform
    if args.len() > 1 {
        build_file(&args[1], &targetspec.intermediate);
        externalize(&targetspec.externalize).unwrap();
    } else {
        repl(targetspec);
    }
}
